#!/usr/bin/env dart

import 'dart:io';

import 'package:yaml/yaml.dart';

void main() {
  final packagesDir = Directory('packages');
  final outputPath = 'packages/marionette_mcp/lib/src/version.g.dart';

  if (!packagesDir.existsSync()) {
    stderr.writeln('ERROR: packages directory not found');
    exit(1);
  }

  // Discover all packages by listing subdirectories that contain a pubspec.yaml
  final packages = <String, PackageInfo>{};
  final entries = packagesDir.listSync().whereType<Directory>().toList()
    ..sort((a, b) => a.path.compareTo(b.path));

  for (final dir in entries) {
    final pubspecPath = '${dir.path}/pubspec.yaml';
    final pubspecFile = File(pubspecPath);
    if (pubspecFile.existsSync()) {
      final info = parsePubspec(pubspecPath);
      packages[info.name] = info;
      print('${info.name} version: ${info.version}');
    }
  }

  if (packages.isEmpty) {
    stderr.writeln('ERROR: No packages found in packages/');
    exit(1);
  }

  // Validate version format for all packages
  for (final info in packages.values) {
    if (!isValidVersion(info.version)) {
      stderr.writeln(
        'ERROR: Invalid version format in ${info.name}: ${info.version}\n'
        'Version must follow semantic versioning (e.g., 1.0.0, 0.2.3, 1.2.3-beta)',
      );
      exit(1);
    }
  }

  // Check that all versions match
  final versions = packages.values.map((p) => p.version).toSet();
  if (versions.length != 1) {
    final mismatchDetails =
        packages.values.map((p) => '  ${p.name}: ${p.version}').join('\n');
    stderr.writeln(
      'ERROR: Version mismatch!\n'
      '$mismatchDetails\n'
      'All packages must have the same version.',
    );
    exit(1);
  }

  final version = versions.single;

  // Check that internal dependency constraints reference the exact version
  final packageNames = packages.keys.toSet();
  var hasDependencyError = false;

  for (final info in packages.values) {
    for (final dep in info.dependencies.entries) {
      if (packageNames.contains(dep.key)) {
        final expected = '^$version';
        if (dep.value != expected) {
          stderr.writeln(
            'ERROR: ${info.name} depends on ${dep.key} with '
            'constraint "${dep.value}", expected "$expected"',
          );
          hasDependencyError = true;
        }
      }
    }
  }

  if (hasDependencyError) {
    exit(1);
  }

  // Generate version.g.dart
  final generatedContent = '''
// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by tool/generate_version.dart

const version = '$version';
''';

  final outputFile = File(outputPath);
  // Ensure the directory exists
  outputFile.parent.createSync(recursive: true);
  outputFile.writeAsStringSync(generatedContent);

  print('Generated $outputPath with version: $version');
}

class PackageInfo {
  final String name;
  final String version;

  /// Maps dependency name to its version constraint string.
  /// Only includes dependencies with a simple version string (not SDK or path deps).
  final Map<String, String> dependencies;

  PackageInfo({
    required this.name,
    required this.version,
    required this.dependencies,
  });
}

PackageInfo parsePubspec(String pubspecPath) {
  final file = File(pubspecPath);

  if (!file.existsSync()) {
    stderr.writeln('ERROR: File not found: $pubspecPath');
    exit(1);
  }

  try {
    final content = file.readAsStringSync();
    final yaml = loadYaml(content) as Map;

    final name = yaml['name']?.toString();
    if (name == null || name.isEmpty) {
      stderr.writeln('ERROR: Package name not found in $pubspecPath');
      exit(1);
    }

    final version = yaml['version']?.toString();
    if (version == null || version.isEmpty) {
      stderr.writeln('ERROR: Version not found in $pubspecPath');
      exit(1);
    }

    final dependencies = <String, String>{};
    final deps = yaml['dependencies'];
    if (deps is Map) {
      for (final entry in deps.entries) {
        final key = entry.key.toString();
        final value = entry.value;
        // Only collect simple version constraint strings (e.g. "^0.3.0"),
        // skip SDK refs, path deps, and hosted deps (which are Maps).
        if (value is String) {
          dependencies[key] = value;
        }
      }
    }

    return PackageInfo(
      name: name,
      version: version,
      dependencies: dependencies,
    );
  } on YamlException catch (e) {
    stderr.writeln('ERROR: Failed to parse YAML in $pubspecPath: $e');
    exit(1);
  } catch (e) {
    stderr.writeln('ERROR: Failed to read $pubspecPath: $e');
    exit(1);
  }
}

bool isValidVersion(String version) {
  // Basic semantic versioning pattern: major.minor.patch with optional pre-release and build metadata
  // Examples: 1.0.0, 0.2.3, 1.2.3-beta, 1.0.0+build123, 1.2.3-alpha.1+build.456
  final semverPattern = RegExp(
    r'^\d+\.\d+\.\d+(-[0-9A-Za-z\-\.]+)?(\+[0-9A-Za-z\-\.]+)?$',
  );
  return semverPattern.hasMatch(version);
}
